// tslint:disable:no-unused-expression
// tslint:disable:variable-name

import { assert, expect, should, use } from "chai";
import * as sinonChai from "sinon-chai";
import { readUInt24 } from "./lib";
import { Commands, EnergyMeasurementTypes, parseMessage, SwitchSource } from "./server";

// enable the should interface with sinon
should();
use(sinonChai);

const INIT1_resp = Buffer.from([0x5A, 0xA5, 0x00, 0x0B, 0x03, 0x01, 0x0A, 0xC0, 0x32, 0x23, 0x62, 0x8A, 0x7E, 0x01, 0xC2, 0xAF, 0x5B, 0xB5]);
const invalid_checksum = Buffer.from([0x5A, 0xA5, 0x00, 0x0B, 0x03, 0x01, 0x0A, 0xC0, 0x32, 0x23, 0x62, 0x8A, 0x7E, 0x01, 0xC2, 0xAE, 0x5B, 0xB5]);
const INIT2_resp1 = Buffer.from([0x5A, 0xA5, 0x00, 0x12, 0x07, 0x01, 0x0A, 0xC0, 0x32, 0x23, 0x62, 0x8A, 0x7E, 0x00, 0x01, 0x06, 0xAC, 0xCF, 0x23, 0x62, 0x8A, 0x7E, 0x5F, 0x5B, 0xB5]);
const INIT2_resp2 = Buffer.from([0x5A, 0xA5, 0x00, 0x12, 0x07, 0x01, 0x0A, 0xC0, 0x32, 0x23, 0x62, 0x8A, 0x7E, 0x00, 0x02, 0x05, 0x00, 0x01, 0x01, 0x08, 0x11, 0x4C, 0x5B, 0xB5]);
const measurement = Buffer.from([0x5a, 0xa5, 0x00, 0x16, 0x90, 0x01, 0x0a, 0xe0, 0x35, 0x23, 0xd3, 0x23, 0xda, 0xff, 0xfe, 0x01, 0x81, 0x39, 0x00, 0x00, 0x01, 0x01, 0x20, 0x00, 0x1c, 0x07, 0x5f, 0x5b, 0xb5]);
const measurement2 = Buffer.from([0x5a, 0xa5, 0x00, 0x16, 0x90, 0x01, 0x0a, 0xe0, 0x35, 0x23, 0xd3, 0x23, 0xda, 0xff, 0xfe, 0x01, 0x81, 0x39, 0x00, 0x00, 0x01, 0x03, 0x20, 0x00, 0x58, 0x0b, 0x1d, 0x5b, 0xb5]);
const measurement3 = Buffer.from([0x5A, 0xA5, 0x00, 0x15, 0x90, 0x01, 0x0A, 0xE0, 0x32, 0x23, 0x62, 0x8A, 0x7E, 0x00, 0x00, 0x00, 0x81, 0x11, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x32, 0x5B, 0xB5]);

describe("server: message handling => ", () => {
	it("should correctly read the INIT1 response", () => {
		const msg = parseMessage(INIT1_resp);
		expect(msg.bytesRead).to.equal(INIT1_resp.length);
		expect(msg.msg.command).to.equal(Commands.init1_response);
	});

	it("should return null when a response is cut short", () => {
		const resp = parseMessage(INIT1_resp.slice(0, INIT1_resp.length - 1));
		expect(resp).to.be.null;
	});

	it("should throw on invalid checksums", () => {
		const thisThrows = () => parseMessage(invalid_checksum);
		expect(thisThrows).to.throw();
	});

	// it("let's see", () => {
	// 	const msg = parseMessage(measurement3).msg;
	// 	if (msg.payload.length === 0x14) {
	// 		// 1st case: on/off report
	// 		console.log("state = " + (msg.payload[msg.payload.length - 1] > 0));
	// 		console.log("lastSwitchSource = " + (SwitchSource[msg.payload[11]]));
	// 	} else if (msg.payload.length === 0x15) {
	// 		// 2nd case: energy report
	// 		const type = msg.payload[16];
	// 		const value = readUInt24(msg.payload, msg.payload.length - 3) / 100;
	// 		const typeName = EnergyMeasurementTypes[type];
	// 		console.log("energyMeasurement > " + typeName + " = " + value);
	// 	}
	// });
});
